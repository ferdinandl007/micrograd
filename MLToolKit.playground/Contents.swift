import Foundation
import PlaygroundSupport
// create values for computation
var a = Value(data: -4.0)
var b = Value(data: 2.0)
// these values can be added
var c = a + b
// or multiplied and taken to the power off.
var d = (a * b) + (b ** 3)
c = c + c + 1
c = c + 1 + c + (-a)
c.description
// additionally we can apply activation functions to these values.
d = d + (d * 2) + (b + a).relu()
d = d + (3 * d) + (b - a).relu()
d.description




var e = c - d
var f = (e ** 2)
var g = f / 2.0
g = g + (10.0 / f)
// we can also perform back propagation.
g.backward()
g.description
// additionally print the ML network
Node(value: g).printTree()

print(a, b, g)

// using the loading function we can load some sample data.
let result = getMoonsData()




// we can construct a simple two layer network here.
var model = MLP(nin: 2, nouts: [16, 16, 1]) // 2-layer neural network
print(model)
print("number of parameters \(model.parameters().count)")


let data: [[Double]] = result.map { $0.imageData }
let labels: [Int] = result.map { $0.label }


// Finally, Python's plot routines can be made available manually
let matplotlib_pyplotModule = PythonModule(named: "matplotlib.pyplot")
let imshowFunction = matplotlib_pyplotModule.function(named: "imshow")
let scatterFunction = matplotlib_pyplotModule.function(named: "scatter")
let showFunction = matplotlib_pyplotModule.function(named: "show")

// This is the code normally generated by the script bridgegen.py
func imshow(_ X: Any? = nil, _ cmap: Any? = nil, _ norm: Any? = nil, _ aspect: Any? = nil, _ interpolation: Any? = nil, _ alpha: Any? = nil, _ vmin: Any? = nil, _ vmax: Any? = nil, _ origin: Any? = nil, _ extent: Any? = nil, _ shape: Any? = nil, _ filternorm: Any = 1, _ filterrad: Any = 4.0, _ imlim: Any? = nil, _ resample: Any? = nil, _ url: Any? = nil, _ hold: Any? = nil, kw: [String: Any]? = nil) -> PythonObject {
    return imshowFunction.call(args: [X, cmap, norm, aspect, interpolation, alpha, vmin, vmax, origin, extent, shape, filternorm, filterrad, imlim, resample, url, hold], kw: kw)
}

func transpose(arr: [[Any]]) -> [[Any]]{
  var output_arr: [[Any]] = arr[0].map{ i in return [Any]() }
  for arr_elem in arr {
    for (i, d) in arr_elem.enumerated() {
      output_arr[i].append(d)
    }
  }
  return output_arr
}


func scatter(_ x: Any? = nil, _ y: Any? = nil, s: Any? = nil, c: Any? = nil, marker: Any? = "o", cmap: Any? = nil, norm: Any? = nil, vmin: Any? = nil, vmax: Any? = nil, alpha: Any? = nil, linewidths: Any? = nil, edgecolors: Any? = nil, plotnonfinite: Any? = false, kw: [String: Any]? = nil) -> PythonObject {
    return scatterFunction.call(args: [x, y, s, c, marker, cmap], kw: kw)
}

func show(_ kw: [String: Any]? = nil) -> PythonObject {
    return showFunction.call(args: [], kw: kw)
}


for k in 0 ... 50 {
    // forward
    let inputs = data.map { x -> [Value] in
        let t = x.map { Value(data: Decimal($0)) }
        return t
    }

    let scores = inputs.map { model.eval(x: $0) }

    // svm "max-margin" loss
    let losses = zip(labels, scores).map { (yi, scoresi) -> [Value] in
        scoresi.map { (1 + (Decimal(-yi) * $0)).relu() }
    }.flatMap { $0 }

    let dataLoss = losses.reduce(Value(data: 0), +) * (1.0 / Decimal(losses.count))

    // L2 regularization
    let alpha: Decimal = 0.0001
    let p = model.parameters().map { $0 * $0 }
    let regLoss = alpha * p.reduce(Value(data: 0), +)
    let total_loss = dataLoss + regLoss
    // Also get accuracy
    let accuracy = zip(labels, scores).map({ (yi, scoresi) -> [Decimal] in
        scoresi.map { s in
            if (yi > 0) == (s.data > 0) {
                return 1
            }
            return 0
        }
    }
    ).flatMap { $0 }.reduce(0.0, +)

    let acc = accuracy / Decimal(labels.count)

    // backward
    model.zero_grad()
    total_loss.forward()
    total_loss.backward()

    // update (sgd)
    let learning_rate = 1.0 - 0.9 * Decimal(k) / 50
    for p in model.parameters() {
        p.data -= learning_rate * p.grad
    }
    if k % 1 == 0 {
        print("step \(k) loss \(total_loss.data), accuracy \(acc * 100)%")
    }
    
}



print(model.eval(x: (result.first?.imageData.map { Value(data: Decimal($0)) })!))


print(model.parameters())


print("Mandelbrot window may appear behind the playground/workspace")


let inputs = data.map { x -> [Value] in
        let t = x.map { Value(data: Decimal($0)) }
        return t
    }

let scores = inputs.map { model.eval(x: $0) }

let prediction = scores.map{ (yi) -> Int in  if yi[0].data > 0 {return 1} else {return -1}}

let transposed = transpose(arr: data)

scatter(transposed[0], transposed[1], s: 150, c: prediction, marker: "x", cmap: "jet")

scatter( transposed[0], transposed[1], s: 20, c: labels, marker: "o", cmap: "jet")

show(["block": false])

PlaygroundPage.current.needsIndefiniteExecution = true


